name: CI - Integration Test (Stage)

on:
  push:
    branches: [ "stage" ]
  pull_request:
    branches: [ "stage" ]

jobs:
  test:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # 1. 네트워크 생성
      - name: Create Network
        run: |
          if (-not (docker network ls -q -f name=test-net)) {
            docker network create test-net
          }

      # 2. [수정] 서버용 이미지 빌드 (Target: production)
      # 이 이미지는 'python main.py'를 실행하여 계속 켜져있게 됩니다.
      - name: Build Production Image
        run: |
          docker build --target production -t my-app:prod -f app/Dockerfile .

      # 3. [수정] 테스트 러너 이미지 빌드 (Target: test-image)
      # 이 이미지는 'pytest'를 실행하고 결과를 알려줍니다.
      - name: Build Test Runner Image
        run: |
          docker build --target test-image -t my-app:tester -f app/Dockerfile .

      # 4. [수정] 앱 컨테이너 실행 (Prod 이미지 사용!)
      - name: Run App Container
        run: |
          docker rm -f app-test 2> $null
          # my-app:test 가 아니라 my-app:prod 를 실행해야 서버가 뜹니다!
          docker run -d --name app-test --network test-net -p 5001:5000 my-app:prod
        continue-on-error: true

      # 5. 서버 대기
      - name: Wait for Server
        run: Start-Sleep -Seconds 5

      # 6. [디버깅] 진짜 살아있는지 로그로 확인 (이제 Up 상태여야 함)
      - name: Check App Status
        run: |
          echo "=== Container List ==="
          docker ps -a
          echo "=== App Logs ==="
          docker logs app-test

      # 7. [수정] 테스트 실행 (Tester 이미지 사용!)
      - name: Run Tests
        run: |
          docker run --rm --network test-net `
            -e App_URL="http://app-test:5000" `
            my-app:tester

      # 8. 뒷정리
      - name: Cleanup
        if: always()
        run: docker rm -f app-test
        continue-on-error: true